name: CI/CD Pipeline

on:
  push:
    branches: [main, develop, feature/*]
  pull_request:
    branches: [main, develop]

# Restrict default permissions for enhanced security
permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  CACHE_KEY_PREFIX: v1

jobs:
  quality:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for SonarQube

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Cache TypeScript build
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            node_modules/.cache
            tsconfig.tsbuildinfo
            tsconfig.worker.tsbuildinfo
          key: ${{ env.CACHE_KEY_PREFIX }}-typescript-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ env.CACHE_KEY_PREFIX }}-typescript-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-
            ${{ env.CACHE_KEY_PREFIX }}-typescript-${{ runner.os }}-

      - name: Build Web Worker
        run: npm run build:worker

      - name: TypeScript & Lint Check
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Run quality check
        run: npm run check

  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Build Web Worker
        run: npm run build:worker

      - name: Run tests with coverage
        run: npm run test:ci
        env:
          CI: true

      - name: Archive test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: coverage/
          retention-days: 7

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [quality, test]
    timeout-minutes: 15

    outputs:
      build-success: ${{ steps.build-check.outputs.success }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Check build artifacts
        id: build-check
        run: |
          if [ -d "out" ] && [ "$(ls -A out)" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Build successful - static export generated"
            ls -la out/
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "‚ùå Build failed - no output directory found"
            exit 1
          fi

      - name: Archive build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: out/
          retention-days: 7

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run security audit
        run: |
          echo "üîç Running comprehensive security audit..."

          # Run full audit for reporting (don't fail on this)
          echo "üìä Full audit report:"
          npm audit || true

          echo ""
          echo "üéØ Checking production dependencies only..."

          # Check production dependencies only for critical vulnerabilities
          PROD_AUDIT=$(npm audit --only=prod --json 2>/dev/null || echo '{}')
          PROD_CRITICAL=$(echo "$PROD_AUDIT" | jq -r '.metadata.vulnerabilities.critical // 0' 2>/dev/null || echo '0')
          PROD_HIGH=$(echo "$PROD_AUDIT" | jq -r '.metadata.vulnerabilities.high // 0' 2>/dev/null || echo '0')

          echo "Production dependencies:"
          echo "  - Critical: $PROD_CRITICAL"
          echo "  - High: $PROD_HIGH"

      - name: Check critical vulnerabilities in production
        run: |
          # Only fail on critical vulnerabilities in production dependencies
          PROD_AUDIT=$(npm audit --only=prod --json 2>/dev/null || echo '{}')
          PROD_CRITICAL=$(echo "$PROD_AUDIT" | jq -r '.metadata.vulnerabilities.critical // 0' 2>/dev/null || echo '0')

          if [ "$PROD_CRITICAL" -gt 0 ]; then
            echo "‚ùå Found $PROD_CRITICAL critical vulnerabilities in production dependencies"
            echo "üö® This requires immediate attention:"
            npm audit --only=prod --audit-level=critical
            exit 1
          else
            echo "‚úÖ No critical vulnerabilities found in production dependencies"
            echo "üéâ Production dependencies are secure"
          fi

  documentation:
    name: Documentation Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Ruby (for AsciiDoctor)
        uses: ruby/setup-ruby@v1.256.0
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: Install AsciiDoctor
        run: |
          gem install asciidoctor
          gem install asciidoctor-html5s
          gem install asciidoctor-diagram

      - name: Validate AsciiDoc syntax
        run: |
          echo "üîç Validating AsciiDoc files..."

          # Find all AsciiDoc files
          find . -name "*.adoc" -type f > adoc_files.txt

          if [ ! -s adoc_files.txt ]; then
            echo "‚ö†Ô∏è  No AsciiDoc files found"
            exit 0
          fi

          echo "üìÑ Found $(wc -l < adoc_files.txt) AsciiDoc files"

          # Validate each file
          validation_failed=false
          while IFS= read -r file; do
            echo "Validating: \"$file\""

            # Check syntax by attempting to convert to HTML
            if ! asciidoctor --safe-mode unsafe --no-header-footer -o /dev/null "$file" 2>/dev/null; then
              echo "‚ùå Syntax error in: \"$file\""
              asciidoctor --safe-mode unsafe --no-header-footer -o /dev/null "$file"
              validation_failed=true
            else
              echo "‚úÖ Valid: \"$file\""
            fi
          done < adoc_files.txt

          if [ "$validation_failed" = true ]; then
            echo "‚ùå AsciiDoc validation failed"
            exit 1
          else
            echo "‚úÖ All AsciiDoc files are valid"
          fi

      - name: Check documentation structure
        run: |
          echo "üèóÔ∏è  Checking documentation structure..."

          # Check for required sections in main documentation
          main_doc="src/docs/index.adoc"
          if [ -f "$main_doc" ]; then
            echo "‚úÖ Main documentation found: $main_doc"

            # Check for required elements
            required_elements=("= " ":toc:" "== Overview")
            for element in "${required_elements[@]}"; do
              if grep -q "$element" "$main_doc"; then
                echo "‚úÖ Found required element: $element"
              else
                echo "‚ö†Ô∏è  Missing recommended element: $element"
              fi
            done
          else
            echo "‚ö†Ô∏è  Main documentation not found at: $main_doc"
          fi

      - name: Generate documentation summary
        run: |
          echo "üìä Documentation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Count documentation files
          total_adoc=$(find . -name "*.adoc" -type f | wc -l)
          echo "- **Total AsciiDoc files**: $total_adoc" >> $GITHUB_STEP_SUMMARY

          # List documentation categories
          echo "- **Documentation structure**:" >> $GITHUB_STEP_SUMMARY
          find src/docs -name "*.adoc" -type f | head -10 | while read -r file; do
            echo "  - \`$file\`" >> $GITHUB_STEP_SUMMARY
          done

          if [ $total_adoc -gt 10 ]; then
            echo "  - ... and $(($total_adoc - 10)) more files" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ **Validation Status**: All documentation files passed validation" >> $GITHUB_STEP_SUMMARY

  sonarqube:
    name: SonarQube Analysis
    runs-on: ubuntu-latest
    needs: [test]
    timeout-minutes: 15
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for better analysis

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Download test results
        uses: actions/download-artifact@v4
        with:
          name: test-results
          path: ./coverage/
        continue-on-error: true

      - name: Verify and prepare test coverage files
        run: |
          echo "üîç Checking coverage files structure..."
          find . -name "*.xml" -o -name "*.info" | head -10

          echo ""
          echo "üìÅ Coverage directory contents:"
          ls -la coverage/ 2>/dev/null || echo "No coverage directory found"

          # Check if generic-report.xml exists
          if [ ! -f "coverage/generic-report.xml" ] || [ ! -f "coverage/lcov.info" ]; then
            echo "‚ùå Coverage files missing - regenerating test coverage..."
            npm run test:ci
            echo ""
            echo "üìÅ After regeneration:"
            ls -la coverage/
          else
            echo "‚úÖ Coverage files found"
            echo "üìÑ Generic report preview:"
            head -n 10 coverage/generic-report.xml
          fi

          # Verify final state
          if [ -f "coverage/generic-report.xml" ]; then
            echo "‚úÖ Generic test execution report ready"
            wc -l coverage/generic-report.xml
          else
            echo "‚ùå Failed to create generic-report.xml"
            exit 1
          fi

          if [ -f "coverage/lcov.info" ]; then
            echo "‚úÖ LCOV coverage report ready"
            wc -l coverage/lcov.info
          else
            echo "‚ùå Failed to create lcov.info"
            exit 1
          fi

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2.1.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io

      - name: SonarQube Quality Gate Check (Optional)
        id: sonar-quality-gate
        uses: sonarsource/sonarqube-quality-gate-action@v1.2.0
        timeout-minutes: 5
        continue-on-error: true # Never block deployment on quality gate failure
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: SonarQube Quality Gate Notification
        if: always()
        run: |
          if [[ "${{ steps.sonar-quality-gate.outcome }}" == "success" ]]; then
            echo "‚úÖ SonarQube Quality Gate: PASSED"
            echo "üéâ All quality conditions met successfully!"
            echo "## ‚úÖ SonarQube Quality Gate: PASSED" >> $GITHUB_STEP_SUMMARY
            echo "All quality conditions met successfully! üéâ" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.sonar-quality-gate.outcome }}" == "failure" ]]; then
            echo "‚ö†Ô∏è SonarQube Quality Gate: FAILED"
            echo "üìã Some quality conditions were not met, but deployment will continue"
            echo "üîç Review details at: https://sonarcloud.io/project/overview?id=Ahmed-Shehzad_Portfolio"
            echo "## ‚ö†Ô∏è SonarQube Quality Gate: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Some quality conditions were not met, but **deployment will continue**. üìã" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üîç [View detailed analysis results ‚Üí](https://sonarcloud.io/project/overview?id=Ahmed-Shehzad_Portfolio)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ÑπÔ∏è SonarQube Quality Gate: SKIPPED or TIMEOUT"
            echo "‚è±Ô∏è Quality gate check did not complete within timeout"
            echo "## ‚ÑπÔ∏è SonarQube Quality Gate: INCOMPLETE" >> $GITHUB_STEP_SUMMARY
            echo "Quality gate check did not complete within timeout. ‚è±Ô∏è" >> $GITHUB_STEP_SUMMARY
          fi
          echo ""
          echo "üìå Note: Quality gate status is informational only and does not affect deployment"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìå Note**: Quality gate status is informational only and does not affect deployment." >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: [build, security]
    timeout-minutes: 10
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    permissions:
      contents: read
      pages: write
      id-token: write

    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: out/

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload to GitHub Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: out/

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Verify deployment
        run: |
          echo "üöÄ Deployment successful!"
          echo "üì± Site URL: ${{ steps.deployment.outputs.page_url }}"

  lighthouse:
    name: Performance Audit
    runs-on: ubuntu-latest
    needs: [deploy]
    timeout-minutes: 10
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Wait for deployment
        run: sleep 30 # Wait for GitHub Pages to be ready

      - name: Lighthouse CI
        uses: treosh/lighthouse-ci-action@v11
        with:
          urls: |
            https://ahmed-shehzad.github.io/Portfolio
          configPath: ./.github/lighthouse/config.json
          uploadArtifacts: true
          temporaryPublicStorage: true

  notify:
    name: Notification
    runs-on: ubuntu-latest
    needs: [quality, test, build, security, documentation, deploy]
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [[ "${{ needs.quality.result }}" == "success" &&
                "${{ needs.test.result }}" == "success" &&
                "${{ needs.build.result }}" == "success" &&
                "${{ needs.security.result }}" == "success" &&
                "${{ needs.documentation.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=‚úÖ Pipeline completed successfully!" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=‚ùå Pipeline failed. Check the logs for details." >> $GITHUB_OUTPUT
          fi

      - name: Pipeline Summary
        run: |
          echo "## üìã Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Quality Check**: ${{ needs.quality.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: ${{ needs.test.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: ${{ needs.build.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Security**: ${{ needs.security.result == 'success' && '‚úÖ Passed' || needs.security.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Documentation**: ${{ needs.documentation.result == 'success' && '‚úÖ Passed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deploy**: ${{ needs.deploy.result == 'success' && '‚úÖ Deployed' || needs.deploy.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Overall Status**: ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
