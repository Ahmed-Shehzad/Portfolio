name: CI/CD - Vercel Deployment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:

# Security: restrict default permissions
permissions:
  contents: read
  deployments: write
  statuses: write
  checks: write
  pull-requests: write
  actions: write # Needed for artifact cleanup

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "20"
  CACHE_KEY_PREFIX: v2

jobs:
  # Quality Gates - Code Quality & Testing
  quality:
    name: Quality Gates
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Setup Node.js
        uses: actions/setup-node@1a4442cacd436585916779262731d5b162bc6ec7 # v4.0.3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: |
          npm ci
          # Install Puppeteer dependencies for PDF generation testing
          npx puppeteer browsers install chrome

      - name: Lint code
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Type checking
        run: |
          echo "ðŸ”§ Enhanced TypeScript Quality Gate"
          echo "===================================="

          # Ensure script is executable
          chmod +x ./scripts/type-check-quality-gate.sh

          # Create reports directory if it doesn't exist
          mkdir -p reports

          # Run comprehensive type checking with detailed diagnostics
          npm run type-check:quality-gate

          # Show summary of generated reports
          echo "ðŸ“Š Type checking completed with detailed diagnostics"
          echo "ðŸ“ Generated reports:"
          ls -la reports/ || echo "No reports directory found"

      - name: Upload TypeScript Reports
        if: always() # Upload reports even if type checking fails
        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
        with:
          name: typescript-reports
          path: |
            reports/
            node_modules/.cache/tsconfig.ci.tsbuildinfo
          retention-days: 7

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Run tests
        run: npm run test
        continue-on-error: false

  # Preview Deployment for Pull Requests
  preview:
    name: Preview Deployment
    runs-on: ubuntu-latest
    needs: quality
    if: github.event_name == 'pull_request'
    timeout-minutes: 15

    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Setup Node.js
        uses: actions/setup-node@1a4442cacd436585916779262731d5b162bc6ec7 # v4.0.3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: |
          npm ci
          # Install Puppeteer dependencies for PDF generation
          npx puppeteer browsers install chrome

      - name: Setup Vercel CLI
        run: npm install -g vercel@latest

      - name: Pull Vercel Environment Information
        run: |
          echo "VERCEL_ORG_ID=$VERCEL_ORG_ID" >> $GITHUB_ENV
          echo "VERCEL_PROJECT_ID=$VERCEL_PROJECT_ID" >> $GITHUB_ENV
          vercel pull --yes --environment=preview --token="$VERCEL_TOKEN"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build and Deploy to Vercel Preview
        id: preview-deploy
        run: |
          vercel build
          deployment_url=$(vercel deploy --prebuilt --token="$VERCEL_TOKEN" --scope="$VERCEL_ORG_ID")
          echo "preview-url=$deployment_url" >> $GITHUB_OUTPUT
          echo "ðŸš€ Preview deployment completed: $deployment_url"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Verify preview deployment
        env:
          # For preview deployments, use the preview URL
          PREVIEW_URL: ${{ steps.preview-deploy.outputs.preview-url }}
        run: |
          echo "ðŸ” Preview deployment completed!"
          echo "ðŸ“Š Preview URL: $PREVIEW_URL"

          echo "Performing preview deployment health check..."

          # Check if the preview URL responds
          response_code=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL" || echo "000")
          echo "Preview response code: $response_code"

          if [ "$response_code" = "200" ]; then
            echo "âœ… Preview site is publicly accessible"
          elif [ "$response_code" = "401" ]; then
            echo "âš ï¸ Preview site is protected (401) - this is expected for some preview deployments"
            echo "âœ… Preview deployment successful, but site requires authentication"
          elif [ "$response_code" -ge "400" ] && [ "$response_code" -lt "500" ]; then
            echo "âŒ Preview deployment client error: $response_code"
            exit 1
          elif [ "$response_code" -ge "500" ]; then
            echo "âŒ Preview deployment server error: $response_code"
            exit 1
          elif [ "$response_code" = "000" ]; then
            echo "âŒ Could not connect to preview deployment"
            exit 1
          else
            echo "âœ… Preview deployment accessible with status: $response_code"
          fi

          # Test PDF generation API
          echo "ðŸ” Testing PDF generation API..."
          pdf_response=$(curl -s -o /dev/null -w "%{http_code}" "$PREVIEW_URL/api/resume-pdf" || echo "000")
          echo "PDF API response code: $pdf_response"

          if [ "$pdf_response" = "200" ]; then
            echo "âœ… PDF generation API is working"
          elif [ "$pdf_response" = "500" ]; then
            echo "âš ï¸ PDF API returned 500 - checking error details..."
            # Get error details without failing the deployment
            pdf_error=$(curl -s "$PREVIEW_URL/api/resume-pdf" | head -c 200 || echo "Could not get error details")
            echo "PDF Error: $pdf_error"
            echo "âš ï¸ PDF generation may need attention, but deployment continues"
          else
            echo "âš ï¸ PDF API returned status $pdf_response - may need investigation"
          fi

      - name: Comment PR with Preview URL
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        if: success()
        env:
          PREVIEW_URL: ${{ steps.preview-deploy.outputs.preview-url }}
        with:
          script: |
            const previewUrl = process.env.PREVIEW_URL;

            if (previewUrl) {
              const commentBody = [
                'ðŸš€ **Preview Deployment Ready!**',
                '',
                '**Build Summary:**',
                '- âœ… Quality gates passed',
                '- âœ… Build successful',
                '- âœ… Preview deployed',
                '- âœ… Health check completed',
                '',
                `ðŸ”— **Preview URL:** ${previewUrl}`,
                '',
                'ðŸ“Š **Key Features to Test:**',
                '- Resume page and PDF generation',
                '- All sections load correctly',
                '- Responsive design',
                '- Performance metrics',
                '',
                '*This preview will be automatically updated with new commits.*'
              ].join('\n');

              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              });
            } else {
              console.log('No preview URL available for comment');
            }

  # Production Deployment to Vercel
  production:
    name: Production Deployment
    runs-on: ubuntu-latest
    needs: quality
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 15
    outputs:
      production-url: ${{ steps.deploy.outputs.production-url }}
    environment:
      name: production
      url: ${{ steps.deploy.outputs.production-url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Setup Node.js
        uses: actions/setup-node@1a4442cacd436585916779262731d5b162bc6ec7 # v4.0.3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: |
          npm ci
          # Install Puppeteer dependencies for PDF generation
          npx puppeteer browsers install chrome

      - name: Setup Vercel CLI
        run: npm install -g vercel@latest

      - name: Pull Vercel Environment Information
        run: |
          echo "VERCEL_ORG_ID=$VERCEL_ORG_ID" >> $GITHUB_ENV
          echo "VERCEL_PROJECT_ID=$VERCEL_PROJECT_ID" >> $GITHUB_ENV
          vercel pull --yes --environment=production --token="$VERCEL_TOKEN"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Build and Deploy to Vercel Production
        id: deploy
        run: |
          vercel build --prod
          production_url=$(vercel deploy --prebuilt --prod --token="$VERCEL_TOKEN" --scope="$VERCEL_ORG_ID")
          echo "production-url=$production_url" >> $GITHUB_OUTPUT
          echo "ðŸš€ Production deployment completed: $production_url"
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

      - name: Verify deployment
        env:
          # For production deployments, use the production URL
          DEPLOYMENT_URL: ${{ steps.deploy.outputs.production-url }}
        run: |
          echo "ðŸš€ Production deployment completed!"
          echo "ðŸ“Š Production URL: $DEPLOYMENT_URL"

          # Extract the production domain from the preview URL for production deployments
          # Production deployments should use the main domain, not the preview URL
          if [[ "$DEPLOYMENT_URL" == *"vercel.app"* ]]; then
            # For now, use the preview URL but note it's a production deployment
            echo "â„¹ï¸ Using Vercel preview URL for production deployment validation"
            PRODUCTION_URL="$DEPLOYMENT_URL"
          else
            PRODUCTION_URL="$DEPLOYMENT_URL"
          fi

          echo "Testing production deployment at: $PRODUCTION_URL"

          # For production deployments, the URL might be protected by Vercel's auth
          # Let's try with a more lenient health check
          echo "Performing production deployment health check..."

          # Check if the URL responds (even with auth)
          response_code=$(curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL" || echo "000")
          echo "Response code: $response_code"

          if [ "$response_code" = "200" ]; then
            echo "âœ… Production site is publicly accessible"
          elif [ "$response_code" = "401" ]; then
            echo "âš ï¸ Production site is protected (401) - this may be expected for Vercel deployments"
            echo "âœ… Production deployment successful, but site requires authentication"
          elif [ "$response_code" -ge "400" ] && [ "$response_code" -lt "500" ]; then
            echo "âŒ Production deployment client error: $response_code"
            exit 1
          elif [ "$response_code" -ge "500" ]; then
            echo "âŒ Production deployment server error: $response_code"
            exit 1
          elif [ "$response_code" = "000" ]; then
            echo "âŒ Could not connect to production deployment"
            exit 1
          else
            echo "âœ… Production deployment accessible with status: $response_code"
          fi

          # Test PDF generation API in production
          echo "ðŸ” Testing PDF generation API in production..."
          pdf_response=$(curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL/api/resume-pdf" || echo "000")
          echo "PDF API response code: $pdf_response"

          if [ "$pdf_response" = "200" ]; then
            echo "âœ… Production PDF generation API is working"
          elif [ "$pdf_response" = "500" ]; then
            echo "âš ï¸ Production PDF API returned 500 - checking error details..."
            # Get error details without failing the deployment
            pdf_error=$(curl -s "$PRODUCTION_URL/api/resume-pdf" | head -c 200 || echo "Could not get error details")
            echo "Production PDF Error: $pdf_error"
            echo "âš ï¸ PDF generation may need attention in production"
          else
            echo "âš ï¸ Production PDF API returned status $pdf_response - may need investigation"
          fi

      - name: Post-deployment validation
        env:
          # For production deployments, use the same URL as deployment verification
          SITE_URL: ${{ steps.deploy.outputs.production-url }}
        run: |
          # Test critical endpoints with improved error handling for production
          echo "Testing critical production endpoints..."

          # Function to test endpoint with better error handling
          test_endpoint() {
            local url=$1
            local name=$2
            local response_code=$(curl -s -o /dev/null -w "%{http_code}" "$url" || echo "000")

            echo "Testing production $name ($url): $response_code"

            if [ "$response_code" = "200" ]; then
              echo "âœ… Production $name is publicly accessible"
              return 0
            elif [ "$response_code" = "401" ]; then
              echo "âš ï¸ Production $name is protected (401) - deployment successful but requires auth"
              return 0
            elif [ "$response_code" -ge "400" ] && [ "$response_code" -lt "500" ]; then
              echo "âŒ $name client error: $response_code"
              return 1
            elif [ "$response_code" -ge "500" ]; then
              echo "âŒ $name server error: $response_code"
              return 1
            elif [ "$response_code" = "000" ]; then
              echo "âŒ Could not connect to $name"
              return 1
            else
              echo "âœ… $name accessible with status: $response_code"
              return 0
            fi
          }

          # Test main page
          test_endpoint "$SITE_URL/" "Main page"

          # Test resume page
          test_endpoint "$SITE_URL/resume" "Resume page"

          # Test API routes
          test_endpoint "$SITE_URL/api/robots" "Robots API"

          test_endpoint "$SITE_URL/api/sitemap" "Sitemap API"

          echo "ðŸŽ‰ All critical endpoints tested successfully!"

  # Performance & Security Audit
  audit:
    name: Performance & Security Audit
    runs-on: ubuntu-latest
    needs: production
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4.1.7

      - name: Setup Node.js
        uses: actions/setup-node@1a4442cacd436585916779262731d5b162bc6ec7 # v4.0.3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Security audit
        run: |
          echo "ðŸ” Running security audit..."
          npm audit --audit-level=high

          # Check for known vulnerabilities
          npx audit-ci --config .audit-ci.json || true

  # Cleanup
  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [preview, production, audit]
    if: always() && github.event_name != 'pull_request' # Don't run cleanup on PRs
    timeout-minutes: 5
    continue-on-error: true # Don't fail the workflow if cleanup fails

    steps:
      - name: Delete old artifacts
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            try {
              const artifacts = await github.rest.actions.listArtifactsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              const oldArtifacts = artifacts.data.artifacts.filter(artifact => {
                const ageInMs = Date.now() - new Date(artifact.created_at);
                const ageInDays = ageInMs / (1000 * 60 * 60 * 24);
                return ageInDays > 7; // Keep artifacts for 7 days
              });

              console.log(`Found ${oldArtifacts.length} old artifacts to delete`);

              for (const artifact of oldArtifacts) {
                try {
                  console.log(`Deleting artifact: ${artifact.name} (ID: ${artifact.id})`);
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id
                  });
                  console.log(`Successfully deleted artifact: ${artifact.name}`);
                } catch (error) {
                  console.log(`Failed to delete artifact ${artifact.name}: ${error.message}`);
                  // Continue with other artifacts instead of failing the entire job
                }
              }
            } catch (error) {
              console.log(`Error listing artifacts: ${error.message}`);
              core.setFailed(`Artifact cleanup failed: ${error.message}`);
            }
