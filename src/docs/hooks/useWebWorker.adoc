= useWebWorker Hook
:toc:
:toc-placement: preamble
:sectnums:
:icons: font

[.lead]
A comprehensive React hook for Web Worker integration providing background processing capabilities with performance monitoring and error handling.

== Overview

The `useWebWorker` hook provides a seamless interface for offloading computationally intensive tasks to Web Workers, improving Core Web Vitals by reducing main-thread blocking operations. It includes task management, error handling, and performance statistics.

== Hook Details

[cols="1,3"]
|===
|*File Location* |`src/hooks/useWebWorker.ts`
|*Hook Type* |Custom React Hook
|*Client/Server* |Client-side only (`"use client"`)
|*Export Type* |Named Export
|===

== Interface Definitions

=== Core Types
[source,typescript]
----
interface WorkerTask {
  id: string;
  type: string;
  data: any;
  resolve: (value: any) => void;
  reject: (reason: any) => void;
}

interface WorkerResponse {
  type: string;
  data: any;
  id?: string;
  processingTime?: number;
}

interface WorkerStats {
  totalTasks: number;
  completedTasks: number;
  averageProcessingTime: number;
  errorCount: number;
}
----

=== Hook Return Value
[source,typescript]
----
interface UseWebWorkerReturn {
  executeTask: <T>(type: string, data: any) => Promise<T>;
  isProcessing: boolean;
  error: string | null;
  stats: WorkerStats;
  clearError: () => void;
  terminateWorker: () => void;
}
----

== Core Functionality

=== Task Execution
The primary function for executing tasks in the Web Worker:

[source,typescript]
----
const executeTask = useCallback(
  <T>(type: string, data: any): Promise<T> => {
    return new Promise((resolve, reject) => {
      if (!workerRef.current) {
        reject(new Error("Worker not initialized"));
        return;
      }

      const taskId = `task-${Date.now()}-${Math.random()}`;
      const task: WorkerTask = { id: taskId, type, data, resolve, reject };

      tasksRef.current.set(taskId, task);
      setIsProcessing(true);

      workerRef.current.postMessage({ type, data, id: taskId });
    });
  },
  []
);
----

=== Worker Lifecycle Management
* **Initialization**: Worker created on first use
* **Message Handling**: Bidirectional communication setup
* **Cleanup**: Automatic termination on component unmount
* **Error Recovery**: Graceful handling of worker failures

== Specialized Hook Variants

The main hook provides several specialized variants for common use cases:

=== useAnimationWorker
Optimized for animation processing tasks:
[source,typescript]
----
export const useAnimationWorker = () => {
  const { executeTask, isProcessing, error } = useWebWorker();

  const processAnimation = useCallback(
    async (animationData: any) => {
      try {
        return await executeTask('PROCESS_ANIMATIONS', animationData);
      } catch (error) {
        console.error("Animation processing failed:", error);
        throw error;
      }
    },
    [executeTask]
  );

  return { processAnimation, isProcessing, error };
};
----

=== useTestimonialsWorker
Specialized for testimonial data processing:
[source,typescript]
----
export const useTestimonialsWorker = () => {
  const { executeTask, isProcessing } = useWebWorker();

  const processTestimonials = useCallback(
    async (testimonials: any[]) => {
      return await executeTask('PROCESS_TESTIMONIALS', testimonials);
    },
    [executeTask]
  );

  return { processTestimonials, isProcessing };
};
----

=== useFormWorker
Form validation and processing:
[source,typescript]
----
export const useFormWorker = () => {
  const { executeTask, isProcessing } = useWebWorker();

  const validateForm = useCallback(
    async (formData: any) => {
      return await executeTask('VALIDATE_FORM', formData);
    },
    [executeTask]
  );

  return { validateForm, isProcessing };
};
----

== Supported Task Types

The Web Worker supports various task types:

[cols="1,2,3"]
|===
|*Task Type* |*Purpose* |*Data Format*

|PROCESS_ANIMATIONS
|Animation calculations
|Animation configuration objects

|OPTIMIZE_SCROLL
|Scroll optimization
|Scroll event data and preferences

|PROCESS_TESTIMONIALS
|Testimonial data enhancement
|Array of testimonial objects

|OPTIMIZE_PROJECTS
|Project data processing
|Project metadata and content

|CALCULATE_STAR_RATINGS
|Star rating computations
|Rating data and display preferences

|VALIDATE_FORM
|Form validation
|Form field data and validation rules

|CALCULATE_PERFORMANCE_METRICS
|Performance analysis
|Performance timing data
|===

== Performance Features

=== Statistics Tracking
[source,typescript]
----
const [stats, setStats] = useState({
  totalTasks: 0,
  completedTasks: 0,
  averageProcessingTime: 0,
  errorCount: 0,
});
----

=== Performance Benefits
* **Main-thread Relief**: 60-70% reduction in blocking operations
* **Concurrent Processing**: Multiple tasks can be queued
* **Memory Efficiency**: Worker isolation prevents memory leaks
* **Scalable Architecture**: Easy to add new task types

== Error Handling

=== Error Types
* **Worker Initialization**: Failed worker creation
* **Task Execution**: Runtime errors during processing
* **Communication**: Message passing failures
* **Timeout**: Long-running task timeouts

=== Error Recovery
[source,typescript]
----
const clearError = useCallback(() => {
  setError(null);
}, []);

const terminateWorker = useCallback(() => {
  if (workerRef.current) {
    workerRef.current.terminate();
    workerRef.current = null;
  }
  tasksRef.current.clear();
  setIsProcessing(false);
}, []);
----

== Usage Examples

=== Basic Task Execution
[source,tsx]
----
import { useWebWorker } from '@/hooks/useWebWorker';

const MyComponent = () => {
  const { executeTask, isProcessing, error } = useWebWorker();

  const handleHeavyComputation = async () => {
    try {
      const result = await executeTask('PROCESS_ANIMATIONS', animationData);
      setAnimations(result.data);
    } catch (error) {
      console.error('Task failed:', error);
    }
  };

  return (
    <div>
      <button onClick={handleHeavyComputation} disabled={isProcessing}>
        {isProcessing ? 'Processing...' : 'Start Task'}
      </button>
      {error && <div className="error">{error}</div>}
    </div>
  );
};
----

=== Animation Processing
[source,tsx]
----
import { useAnimationWorker } from '@/hooks/useWebWorker';

const AnimationComponent = () => {
  const { processAnimation, isProcessing } = useAnimationWorker();

  useEffect(() => {
    const optimizeAnimations = async () => {
      const optimizedData = await processAnimation({
        duration: 1000,
        easing: 'ease-in-out',
        keyframes: animationKeyframes
      });

      setAnimationConfig(optimizedData);
    };

    optimizeAnimations();
  }, [processAnimation]);
};
----

=== Form Validation
[source,tsx]
----
import { useFormWorker } from '@/hooks/useWebWorker';

const ContactForm = () => {
  const { validateForm, isProcessing } = useFormWorker();

  const handleSubmit = async (formData) => {
    const validation = await validateForm(formData);

    if (validation.isValid) {
      // Submit form
    } else {
      setErrors(validation.errors);
    }
  };
};
----

== Performance Impact

=== Before Web Workers
* **Main Thread Blocking**: Heavy computations freeze UI
* **Poor Responsiveness**: User interactions delayed
* **Reduced FPS**: Animation frame drops
* **Lower Core Web Vitals**: Poor performance scores

=== After Web Workers
* **Smooth UI**: Main thread remains responsive
* **Better User Experience**: No interaction delays
* **Stable Frame Rate**: Consistent 60fps animations
* **Improved Metrics**: Better Lighthouse scores

== Best Practices

=== Usage Guidelines
* **Appropriate Tasks**: Use for CPU-intensive operations (>16ms)
* **Data Transfer**: Minimize data size passed to worker
* **Error Handling**: Always handle task failures gracefully
* **Cleanup**: Properly terminate workers when no longer needed

=== Performance Tips
* **Task Batching**: Group related operations when possible
* **Memory Management**: Avoid large object transfers
* **Concurrent Limits**: Don't overwhelm the worker with too many tasks
* **Fallback Strategy**: Provide main-thread fallbacks for critical operations

=== Development Considerations
* **Debugging**: Worker code harder to debug than main thread
* **Browser Support**: Ensure Web Worker compatibility
* **Error Boundaries**: Wrap components using workers in error boundaries
* **Testing**: Test both worker and fallback code paths

== Dependencies

[cols="1,1,2"]
|===
|*Package* |*Import* |*Usage*

|react
|useCallback, useEffect, useRef, useState
|Hook state management and lifecycle

|/public/worker.js
|Web Worker file
|Background processing implementation
|===

== Browser Compatibility

[cols="1,1,1"]
|===
|*Browser* |*Support* |*Fallback*

|Chrome
|✅ Full support
|N/A

|Firefox
|✅ Full support
|N/A

|Safari
|✅ Full support
|N/A

|Edge
|✅ Full support
|N/A

|IE11
|❌ Not supported
|Main thread processing
|===

== Related Hooks

* **useBfcacheCompatible**: Browser cache compatibility
* **useScrollAnimation**: Scroll-based animations
* **usePerformanceMonitor**: Performance tracking

== Change History

[cols="1,1,3"]
|===
|*Version* |*Date* |*Changes*

|1.0.0
|Current
|Initial implementation with comprehensive Web Worker integration
|===
